<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Mapper_Telnet"
   author="Nick Gammon"
   id="6069eacf376f5e9dbfce901f"
   language="Lua"
   purpose="Draws room map"
   date_written="2010-02-24"
   requires="4.50"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
Install this plugin to show an your current room name and exits.

The window can be dragged to a new location with the mouse.
]]>
</description>

</plugin>


<!--  Script  -->


<script>
<![CDATA[

FONT_NAME = "Fixedsys"    -- the font we want to use
FONT_SIZE = 9
FONT_ID = "fn"  -- internal font identifier
  
WINDOW_WIDTH = 400
WINDOW_HEIGHT = 400
ROOM_SIZE = 20
DISTANCE_TO_NEXT_ROOM = 30

BACKGROUND_COLOUR = ColourNameToRGB "lightseagreen"
ROOM_COLOUR = ColourNameToRGB "cyan"
EXIT_COLOUR = ColourNameToRGB "darkgreen"
OUR_ROOM_FILL_COLOUR = ColourNameToRGB "bisque"
require "movewindow"
require "serialize"

rooms = {}
requested_rooms = {}

local IAC, SB, SE = 0xFF, 0xFA, 0xF0

-- check if single item cached
function check_cache (guid, item, type)
  local cache = rooms [guid]  -- field to check on
  if cache then
    -- copy in cached stuff
    for k, v in pairs (cache) do
      item [k] = v  
    end -- for
  elseif not requested_rooms [guid] then
      SendPkt (string.char (IAC, SB, 102) .. type .. " = \"" .. guid .. "\"" .. string.char (IAC, SE)) 
      Note ("Requested ", type, " cache ID: ", guid)
      requested_rooms [guid] = GetInfo (232)  -- don't request twice
  end -- if 
end -- check_cache

function check_cache_table (tbl, type)

  if tbl then
    -- for an entire table (eg. objects, players, npcs, rooms) check all for cached guids
    for i, item in ipairs (tbl) do
      check_cache (item.guid, item, type)
    end -- for
  end -- if
  
end -- request_item

function OnPluginInstall ()
  
  win = GetPluginID ()

  WindowCreate (win, 0, 0, 0, 0, 0, 0, 0)
                 
  -- add the font
  WindowFont (win, FONT_ID, FONT_NAME, FONT_SIZE)
  
  -- see how high it is
  font_height = WindowFontInfo (win, FONT_ID, 1)  -- height

  -- find where window was last time
  windowinfo = movewindow.install (win, 7)
   
  assert (loadstring (GetVariable ("rooms") or "")) ()
  
end -- OnPluginInstall

function OnPluginEnable ()
  WindowShow (win, true)
end -- OnPluginDisable

function OnPluginDisable ()
  WindowShow (win, false)
end -- OnPluginDisable

-- hide window on removal
function OnPluginClose ()
  WindowShow (win,  false)  -- hide it
end -- OnPluginClose

function OnPluginSaveState ()
  movewindow.save_state (win)
  SetVariable ("rooms", "rooms = " .. serialize.save_simple (rooms))
end -- OnPluginSaveState

local HALF_ROOM = ROOM_SIZE / 2
local HALF_WAY  = DISTANCE_TO_NEXT_ROOM / 2
local THIRD_WAY  = DISTANCE_TO_NEXT_ROOM / 3

connectors = {
  north = { x1 = 0,             y1 = - HALF_ROOM, x2 = 0,             y2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM, at = { 0, -1 } }, 
  south = { x1 = 0,             y1 =   HALF_ROOM, x2 = 0,             y2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM, at = { 0,  1 } }, 
  east  = { x1 =   HALF_ROOM,   y1 = 0,           x2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM, y2 = 0, at = {  1,  0 }}, 
  west  = { x1 = - HALF_ROOM,   y1 = 0,           x2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM, y2 = 0, at = { -1,  0 }}, 

  northeast = { x1 =   HALF_ROOM, y1 = - HALF_ROOM, x2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM , y2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM, at = { 1, -1 } }, 
  southeast = { x1 =   HALF_ROOM, y1 =   HALF_ROOM, x2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM , y2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM, at = { 1,  1 } }, 
  northwest = { x1 = - HALF_ROOM, y1 = - HALF_ROOM, x2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM , y2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM, at = {-1, -1 } }, 
  southwest = { x1 = - HALF_ROOM, y1 =   HALF_ROOM, x2 = - HALF_ROOM - DISTANCE_TO_NEXT_ROOM , y2 =   HALF_ROOM + DISTANCE_TO_NEXT_ROOM, at = {-1,  1 } }, 

  } -- end connectors
  
half_connectors = {
  north = { x1 = 0,             y1 = - HALF_ROOM, x2 = 0,             y2 = - HALF_ROOM - THIRD_WAY, at = { 0, -1 } }, 
  south = { x1 = 0,             y1 =   HALF_ROOM, x2 = 0,             y2 =   HALF_ROOM + THIRD_WAY, at = { 0,  1 } }, 
  east  = { x1 =   HALF_ROOM,   y1 = 0,           x2 =   HALF_ROOM + THIRD_WAY, y2 = 0, at = {  1,  0 }}, 
  west  = { x1 = - HALF_ROOM,   y1 = 0,           x2 = - HALF_ROOM - THIRD_WAY, y2 = 0, at = { -1,  0 }}, 

  northeast = { x1 =   HALF_ROOM, y1 = - HALF_ROOM, x2 =   HALF_ROOM + THIRD_WAY , y2 = - HALF_ROOM - THIRD_WAY, at = { 1, -1 } }, 
  southeast = { x1 =   HALF_ROOM, y1 =   HALF_ROOM, x2 =   HALF_ROOM + THIRD_WAY , y2 =   HALF_ROOM + THIRD_WAY, at = { 1,  1 } }, 
  northwest = { x1 = - HALF_ROOM, y1 = - HALF_ROOM, x2 = - HALF_ROOM - THIRD_WAY , y2 = - HALF_ROOM - THIRD_WAY, at = {-1, -1 } }, 
  southwest = { x1 =   HALF_ROOM, y1 = - HALF_ROOM, x2 =   HALF_ROOM + THIRD_WAY , y2 = - HALF_ROOM - THIRD_WAY, at = {-1,  1 } }, 

  } -- end half_connectors
  

function draw_room (guid, x, y)

  if drawn [guid] then
    return
  end -- done this one
  
  -- don't draw the same room more than once
  drawn [guid] = true
  
  -- don't draw another room on top of one we already drew
  local coords = string.format ("%i,%i", x, y)
  
  if drawn_coords [coords] then
    return
  end -- if drawn on this spot
  
  drawn_coords [coords] = true
  
  -- can't if we know nothing about it
  if not rooms [guid] then
    return
  end -- not in cache
  
  local left, top, right, bottom = x - HALF_ROOM, y - HALF_ROOM, x + HALF_ROOM, y + HALF_ROOM
  
  -- forget it if off screen
  if x < 0 or y < 0 or x > WINDOW_WIDTH or y > WINDOW_HEIGHT then
     return
  end -- if
  
  -- exits
  
  for name, exit_guid in pairs (rooms [guid].exits) do
    local exit_info = connectors [name]
    if exit_info then
      local linetype = 0 -- unbroken
      if not rooms [exit_guid] then
        linetype = 2 -- dots
      end -- if
      
      local next_x = x + exit_info.at [1] * (ROOM_SIZE + DISTANCE_TO_NEXT_ROOM)
      local next_y = y + exit_info.at [2] * (ROOM_SIZE + DISTANCE_TO_NEXT_ROOM)
      
      local next_coords = string.format ("%i,%i", next_x, next_y)
      if drawn_coords [next_coords] then
        exit_info = half_connectors [name]
      end -- if drawn on this spot

      WindowLine (win, x + exit_info.x1, y + exit_info.y1, x + exit_info.x2, y + exit_info.y2, EXIT_COLOUR, linetype, 1)
      -- recurse to do draw exit
      draw_room (exit_guid, next_x, next_y)
    end -- if we know what to do with this direction
  end -- for each exit

  if guid == current_room then
    WindowRectOp (win, 2, left, top, right, bottom, OUR_ROOM_FILL_COLOUR)
  end -- if the room we are standing in

  -- draw current room (last, so it goes on top)
  WindowRectOp (win, 1, left, top, right, bottom, ROOM_COLOUR)
  
  WindowAddHotspot(win, guid,  
                 left, top, right, bottom,   -- rectangle
                 "",  -- mouseover
                 "",  -- cancelmouseover
                 "",  -- mousedown
                 "",  -- cancelmousedown
                 "",  -- mouseup
                 string.format ("%s\t(%s)", rooms [guid].name, guid),  -- tooltip text
                 1, 0)  -- hand cursor
                   
end -- draw_room

-- here when location changes

function OnPluginTelnetOption (option)

  local t = {}  -- incoming server variables will go into table t
  setfenv (assert (loadstring (option)), t) () -- compile and load into t
  
  -- cache incoming object information
  if t.room_info then
    for k, v in pairs (t.room_info) do
      local time_elapsed = GetInfo (232) - (requested_rooms [k] or GetInfo (232))
      local dsc = v.name or "<elapsed>"
      Note (string.format ("RECEIVED room ID: %s in %.2f seconds (%s).", k, time_elapsed, dsc))
      rooms [k] = v or nil
      requested_rooms [k] = nil
      -- tprint (v)
    end -- for
  end -- if
    
  if t.move then
    redisplay = nil
  else
    -- we couldn't display all last time, and we got some cache info, try again
    if redisplay and t.room_info then
      t.move = redisplay
    else
      return
    end
  end
    
  local width = 0
  local lines = 1  -- have at least one line
  local dark_message = "It is too dark to see."
  local blind_message = "You are blind!"
  local exits_message = "Exits:"
   
  room = {}  -- current room
  
  check_cache_table (t.move.exits,  "room_info")
  check_cache (t.move.guid, room, "room_info")
  
  if not rooms [t.move.guid] then
    redisplay = t.move  -- need to redisplay when cache info arrives
    return
  end -- if
  
  window_width = width + 10
  window_height = font_height * lines + 10
  
  WindowCreate (win, 
                 windowinfo.window_left, 
                 windowinfo.window_top, 
                 WINDOW_WIDTH, WINDOW_HEIGHT,  
                 windowinfo.window_mode,   -- top right
                 windowinfo.window_flags,
                 0) 

  -- let them t.move it around                 
  movewindow.add_drag_handler (win, 0, 0, 0, 0)
    
  
  -- fill entire box to clear it
  WindowRectOp (win, 2, 0, 0, 0, 0, BACKGROUND_COLOUR)  -- fill entire box
   
  -- Edge around box rectangle
  WindowCircleOp (win, 3, 0, 0, 0, 0, ColourNameToRGB "darkgray", 0, 2, 0, 1)

  if t.move.blind then
    WindowText (win, FONT_ID, blind_message, 5, 5, 0, 0, ColourNameToRGB "darkred", true)
  elseif t.move.dark then
    WindowText (win, FONT_ID, dark_message, 5, 5, 0, 0, ColourNameToRGB "darkgreen", true)
  else  
    vertical = 5  -- pixel to start at
    WindowText (win, FONT_ID, t.move.guid, 5, vertical, 0, 0, ColourNameToRGB "saddlebrown", true)
    vertical = vertical + font_height
    if room.name then
      WindowText (win, FONT_ID, room.name, 5, vertical, 0, 0, ColourNameToRGB "saddlebrown", true)
    end -- if
    -- initial room in middle
    drawn = {}  -- to stop double-drawing
    drawn_coords = {}
    current_room = t.move.guid
    draw_room (t.move.guid, WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2)
  end -- if 
  
  -- 3D box
  WindowCircleOp (win, 3, 0, 0, 0, 0, 0x505050, 0, 3, 0, 1)   -- dark grey border (3 pixels)
  WindowCircleOp (win, 3, 1, 1, -1, -1, 0x7C7C7C, 0, 1, 0, 1)  -- lighter inner border
  WindowCircleOp (win, 3, 2, 2, -2, -2, 0, 0, 1, 0, 1)  -- black inside that
  WindowLine (win, 1, 1, WINDOW_WIDTH - 1, 1, 0xC2C2C2, 0, 1)  -- light top edge
  WindowLine (win, 1, 1, 1, WINDOW_HEIGHT - 1, 0xC2C2C2, 0, 1)  -- light left edge (for 3D look)
    
  -- make sure window visible
  WindowShow (win, true)

end -- function OnPluginTelnetOption

]]>
</script>

</muclient>
