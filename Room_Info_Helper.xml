<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, February 28, 2010, 10:44 AM -->
<!-- MuClient version 4.50 -->

<!-- Plugin "Room_Info_Helper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Room_Info_Helper"
   author="Nick Gammon"
   id="8a78c14d185c36109f479926"
   language="Lua"
   purpose="Manages room information for various plugins"
   date_written="2010-02-28 10:43:27"
   requires="4.50"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Install required for Mapper_Telnet and Room_Contents_Telnet plugins.
]]>
</description>

</plugin>


<!--  Script  -->


<script>
<![CDATA[

local PPI = require("ppi")

room_not_in_database = {}
requested_rooms = {}

function dbcheck (code)

 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg ()  -- the rollback will change the error message
    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
    error (err, 2)            -- show error in caller's context
  end -- if

end -- dbcheck 

function fixsql (s)
  if s then
    return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end -- if
end -- fixsql

function fixbool (b)
  if b then
    return 1
  else
    return 0
  end -- if
end -- fixbool

function load_room_from_database (guid)

  local room
 
  -- if not in database, don't look again
  if room_not_in_database [guid] then
    return nil
  end -- no point looking
  
  for row in db:nrows(string.format ("SELECT * FROM rooms WHERE guid = %s", fixsql (guid))) do
     room = {
       name = row.name,
       desc = row.desc,
       shop = row.shop == 1,
       train = row.train == 1,
       repair = row.repair == 1,
       healer = row.healer == 1,
       terrain = row.terrain,
       exits = {} }
      
    for exitrow in db:nrows(string.format ("SELECT * FROM exits WHERE fromguid = %s", fixsql (guid))) do
       room.exits [exitrow.dir] = { 
            guid = tostring (exitrow.toguid), 
            closed = exitrow.closed == 1,
            locked = exitrow.locked == 1,
            }
            
    end -- for each exit
    
  end   -- finding room

  if room then
    return room
  end -- if found
  
  room_not_in_database [guid] = true
  return nil
    
end -- load_room_from_database


local IAC, SB, SE = 0xFF, 0xFA, 0xF0

-- check if single item cached
function get_room (guid, ask_server)

  -- see if in database
  local room = load_room_from_database (guid)
  
  -- yes? just return it then
  if room then
    return room
  end -- if found
  
  if requested_rooms [guid] or not ask_server then
    return nil
  end -- if already asked for it

  SendPkt (string.char (IAC, SB, 102) .. "room_info = \"" .. guid .. "\"" .. string.char (IAC, SE)) 
  -- Note ("Requested cache ID: ", guid)
  
  requested_rooms [guid] = GetInfo (232)  -- don't request twice
  return nil
end -- get_room

function save_room_to_database (guid, room)

  dbcheck (db:execute (string.format ([[
      INSERT INTO rooms (guid, name, desc, shop, train, repair, healer, terrain, date_added) 
          VALUES (%s, %s, %s, %i, %i, %i, %i, %s, DATETIME('NOW'));
    ]], fixsql  (guid),         -- guid is key (guid)
        fixsql  (room.name), 
        fixsql  (room.desc), 
        fixbool (room.shop), 
        fixbool (room.train), 
        fixbool (room.repair), 
        fixbool (room.healer), 
        fixsql  (room.terrain)
         )))
  
  -- for full-text searching
   dbcheck (db:execute (string.format ([[
      INSERT INTO rooms_lookup (guid, name, desc) VALUES (%s, %s, %s);
    ]], fixsql  (guid),       
        fixsql  (room.name), 
        fixsql  (room.desc)
        )))
          
  for name, exit in pairs (room.exits) do
   dbcheck (db:execute (string.format ([[
      INSERT INTO exits (dir, fromguid, toguid, closed, locked, date_added) 
          VALUES (%s, %s, %s, %i, %i, DATETIME('NOW'));
    ]], fixsql  (name),         -- direction (eg. "n")
        fixsql  (guid),         -- from current room
        fixsql  (exit.guid),    -- destination room
        fixbool (exit.closed),  -- exit closed
        fixbool (exit.locked)   -- exit locked
        )))
        
  end -- for each exit
  
  room_not_in_database [guid] = false
    
end -- function 

function find_rooms (match_text)
  local guids = {}
  
  for row in db:nrows(string.format ("SELECT guid, name FROM rooms_lookup WHERE rooms_lookup MATCH %s", fixsql (match_text))) do
     table.insert (guids, { guid = row.guid, name = row.name } )
  end   -- finding room

  return guids
  
end -- find_rooms

function OnPluginInstall ()

 -- open database on disk (uses world name)
  db = assert (sqlite3.open( GetInfo (66) .. WorldName() .. ".db"))
  
  -- create rooms table
  dbcheck (db:execute[[
    PRAGMA foreign_keys = ON;
  
    CREATE TABLE IF NOT EXISTS 
      rooms(
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      guid          STRING NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,     -- name of room
      desc          TEXT,     -- description
      shop          INTEGER,  -- true if shop here
      train         INTEGER,  -- true if trainer here
      repair        INTEGER,  -- true if repairer here
      healer        INTEGER,  -- true if healer here
      terrain       TEXT,     -- terrain type (eg. "outside")
      notes         TEXT,     -- player-added notes
      zone          TEXT,     -- guid of zone
      date_added    DATE,     -- date added to database
      UNIQUE (guid)
    );
    
    CREATE TABLE IF NOT EXISTS 
      zones(
      zoneid        INTEGER PRIMARY KEY AUTOINCREMENT,
      guid          STRING NOT NULL,   -- unique zone identifier
      name          TEXT,     -- name of zone
      desc          TEXT,     -- description
      notes         TEXT,     -- player-added notes,
      low_level     INTEGER,  -- recommended lowest level
      high_level    INTEGER,  -- recommended upper level
      terrain       TEXT,     -- terrain type (eg. "swamp")
      pvp           INTEGER,  -- true if PvP allowed
      date_added    DATE,     -- date added to database
      UNIQUE (guid)
    );
        
    CREATE TABLE IF NOT EXISTS 
      exits(
      exitid      INTEGER PRIMARY KEY AUTOINCREMENT,
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromguid    STRING  NOT NULL, -- exit from which room (in rooms table)
      toguid      string  NOT NULL, -- exit to which room (in rooms table)
      closed      INTEGER,          -- true if closed
      locked      INTEGER,          -- true if locked
      date_added  DATE,             -- date added to database
      FOREIGN KEY(fromguid) REFERENCES rooms(guid)
    );
  CREATE INDEX IF NOT EXISTS fromguid_index ON exits (fromguid);
  CREATE INDEX IF NOT EXISTS toguid_index   ON exits (toguid);
  
  ]])

  -- check if rooms_lookup table exists
  local table_exists
  for a in db:nrows "SELECT * FROM sqlite_master WHERE name = 'rooms_lookup' AND type = 'table'" do
    table_exists = true
  end  -- for
  
  if not table_exists then
    dbcheck (db:execute "CREATE VIRTUAL TABLE rooms_lookup USING FTS3(guid, name, desc, notes);")
  end -- if
  
  PPI.Expose "get_room"
  PPI.Expose "find_rooms"

end -- function OnPluginInstall

function OnPluginClose ()
  -- close database
  db:close()
end -- OnPluginClose

function OnPluginTelnetOption (option)

  local t = {}  -- incoming server variables will go into table t
  setfenv (assert (loadstring (option)), t) () -- compile and load into t
  
  -- cache incoming object information
  if t.room_info then
    
    if next (t.room_info) then
      dbcheck (db:execute "BEGIN TRANSACTION;")
    end -- if at least one room
    
    for k, v in pairs (t.room_info) do
      local time_elapsed = GetInfo (232) - (requested_rooms [k] or GetInfo (232))
      local dsc = "<not there>"
      if v then
        dsc = "found"
      end -- if
      -- Note (string.format ("RECEIVED room ID: %s in %.2f seconds (%s).", k, time_elapsed, dsc))
      requested_rooms [k] = nil
      if v then
        save_room_to_database (k, v)
      end -- if room data found
    end -- for
    
    if next (t.room_info) then
       dbcheck (db:execute "COMMIT;")
    end -- if at least one room
    
  end -- if t.room_info
  
end -- function OnPluginTelnetOption

function OnPluginTelnetRequest (type, data)

  if type == 102 and data == "WILL" then
    return true
  end -- if

end -- function OnPluginTelnetRequest

]]>
</script>


</muclient>
