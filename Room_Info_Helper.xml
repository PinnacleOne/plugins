<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, February 28, 2010, 10:44 AM -->
<!-- MuClient version 4.50 -->

<!-- Plugin "Room_Info_Helper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Room_Info_Helper"
   author="Nick Gammon"
   id="8a78c14d185c36109f479926"
   language="Lua"
   purpose="Manages room information for various plugins"
   date_written="2010-02-28 10:43:27"
   requires="4.50"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Install required for Mapper_Telnet and Room_Contents_Telnet plugins.
]]>
</description>

</plugin>


<!--  Script  -->


<script>
<![CDATA[

local PPI = require("ppi")

room_not_in_database = {}
room_in_database = {}
requested_rooms = {}

function dbcheck (code)

 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg ()  -- the rollback will change the error message
    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
    error (err, 2)            -- show error in caller's context
  end -- if

end -- dbcheck 

function fixsql (s)
  if s then
    return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end -- if
end -- fixsql

function fixbool (b)
  if b then
    return 1
  else
    return 0
  end -- if
end -- fixbool

function load_room_from_database (uid)

  local room
 
  -- if not in database, don't look again
  if room_not_in_database [uid] then
    return nil
  end -- no point looking
  
  for row in db:nrows(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (uid))) do
     room = {
       hash = row.hash,
       exits = {} }
      
    for exitrow in db:nrows(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (uid))) do
       room.exits [exitrow.dir] = { 
            uid = tostring (exitrow.touid), 
            closed = exitrow.closed == 1,
            locked = exitrow.locked == 1,
            door = exitrow.door == 1,
            }
            
    end -- for each exit
    
  end   -- finding room

  if room then
    return room
  end -- if found
  
  room_not_in_database [uid] = true
  return nil
    
end -- load_room_from_database


local IAC, SB, SE = 0xFF, 0xFA, 0xF0

-- check if single item cached
function get_room (uid, ask_server)

  -- see if in database
  local room = load_room_from_database (uid)
  
  -- yes? just return it then
  if room then
    return room
  end -- if found
  
  if requested_rooms [uid] or not ask_server then
    return nil
  end -- if already asked for it

  SendPkt (string.char (IAC, SB, 102) .. "room_info = \"" .. uid .. "\"" .. string.char (IAC, SE)) 
  Note ("Requested cache ID: ", guid)
  
  requested_rooms [uid] = GetInfo (232)  -- don't request twice
  return nil
end -- get_room

function save_room_to_database (uid, hash, contents)

  for row in db:nrows(string.format ("SELECT uid FROM rooms WHERE uid = %s", fixsql (uid))) do
      room_in_database [uid] = true
  end   -- finding room

  if room_in_database [uid] then
    return
  end -- already there
    
  dbcheck (db:execute (string.format ([[
      INSERT INTO rooms (uid, hash, date_added) 
          VALUES (%s, %s, DATETIME('NOW'));
    ]], fixsql (uid), fixsql (hash)
         )))
  
         --[=[
  -- for full-text searching
   dbcheck (db:execute (string.format ([[
      INSERT INTO rooms_lookup (uid, name, desc) VALUES (%s, %s, %s);
    ]], fixsql  (uid),       
        fixsql  (room.name), 
        fixsql  (room.desc)
        )))
      --]=]
          
  for exit, details in pairs (contents) do
     if string.match (exit, "^r%.") then
       dbcheck (db:execute (string.format ([[
          INSERT INTO exits (dir, fromuid, touid, closed, locked, door, date_added) 
              VALUES (%s, %s, %s, %i, %i, %i, DATETIME('NOW'));
        ]], fixsql  (details.dir),  -- direction (eg. "n")
            fixsql  (uid),         -- from current room
            fixsql  (exit),        -- destination room
            fixbool (details.closed),   -- exit closed
            fixbool (details.locked),   -- exit locked
            fixbool (details.door)      -- is a door
           
            )))
      end -- if an exit        
  end -- for each exit
  
  room_not_in_database [uid] = false
    
end -- function 

function find_rooms (match_text)
  local guids = {}
  
  for row in db:nrows(string.format ("SELECT guid, name FROM rooms_lookup WHERE rooms_lookup MATCH %s", fixsql (match_text))) do
     table.insert (guids, { guid = row.guid, name = row.name } )
  end   -- finding room

  return guids
  
end -- find_rooms

function OnPluginInstall ()

 -- open database on disk (uses world address, that is which MUD we are playing)
  db = assert (sqlite3.open( GetInfo (66) .. Trim (WorldAddress ()) .. "_" .. WorldPort () .. ".db"))
  
  -- create rooms table
  dbcheck (db:execute[[
    PRAGMA foreign_keys = ON;
  
    CREATE TABLE IF NOT EXISTS 
      rooms(
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           STRING NOT NULL, -- vnum or how the MUD identifies the room
      hash          TEXT,            -- name of room
      date_added    DATE,            -- date added to database
      UNIQUE (uid)
    );
       
    CREATE TABLE IF NOT EXISTS 
      exits(
      exitid      INTEGER PRIMARY KEY AUTOINCREMENT,
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     STRING  NOT NULL, -- exit from which room (in rooms table)
      touid       STRING  NOT NULL, -- exit to which room (in rooms table)
      closed      INTEGER,          -- true if closed
      locked      INTEGER,          -- true if locked
      door        INTEGER,          -- true if a door
      date_added  DATE,             -- date added to database
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
    );
  CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
  CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
  
  ]])

  --[=[
  -- check if rooms_lookup table exists
  local table_exists
  for a in db:nrows "SELECT * FROM sqlite_master WHERE name = 'rooms_lookup' AND type = 'table'" do
    table_exists = true
  end  -- for
  
  if not table_exists then
    dbcheck (db:execute "CREATE VIRTUAL TABLE rooms_lookup USING FTS3(guid, name, desc, notes);")
  end -- if
  --]=]
  
  
  PPI.Expose "get_room"
  -- PPI.Expose "find_rooms"

end -- function OnPluginInstall

function OnPluginClose ()
  -- close database
  db:close()
end -- OnPluginClose

function OnPluginTelnetOption (option)

  local t = {}  -- incoming server variables will go into table t
  setfenv (assert (loadstring (option)), t) () -- compile and load into t
  
  --for k in pairs (t) do
  --  print ("Received telnet item:", k, "in plugin", GetPluginName ())
  --end -- for
  
  -- cache incoming object information
  if t.inroom then
    
    if not room_in_database [t.inroom.uid] and next (t.inroom.contents) then

      dbcheck (db:execute "BEGIN TRANSACTION;")

      requested_rooms [t.inroom.uid] = nil
    
      local time_elapsed = GetInfo (232) - (requested_rooms [k] or GetInfo (232))
      Note (string.format ("RECEIVED room ID: %s in %.2f seconds.", t.inroom.uid, time_elapsed))
      save_room_to_database (t.inroom.uid, t.inroom.hash, t.inroom.contents)
      
      dbcheck (db:execute "COMMIT;")
      
    end -- not already in database
        
  end -- if t.room_info
  
end -- function OnPluginTelnetOption

function OnPluginTelnetRequest (type, data)

  if type == 102 and data == "WILL" then
    return true
  end -- if

end -- function OnPluginTelnetRequest

]]>
</script>


</muclient>
