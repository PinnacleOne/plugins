<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Health_Bar_Miniwindow_Telnet"
   author="Nick Gammon"
   id="083960a6b070bb36e8775b1e"
   language="Lua"
   purpose="Shows stats in a mini window"
   date_written="2010-02-17"
   requires="4.49"
   version="2.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
Install this plugin to show an info bar with HP, Mana, 
and Movement points shown as a bar.

The window can be dragged to a new location with the mouse.
]]>
</description>

</plugin>


<!--  Script  -->


<script>
<![CDATA[

GAP_BETWEEN_BARS = 4
 
WINDOW_WIDTH = 300   -- width of entire status window
NUMBER_OF_TICKS = 5  -- number of tick marks

require "movewindow"
require "gauge"
require "pairsbykeys"
require "serialize"

FONT_NAME = get_preferred_font {"Sylfaen", "Dina", "Lucida Console", "Fixedsys", "Courier" } 
FONT_SIZE = 10
FONT_ID = "fn"  -- internal font identifier
  
BUFF_FONT_NAME = get_preferred_font {"Trebuchet MS", "Sylfaen", "Lucida Console", "Fixedsys", "Courier" } 
BUFF_FONT_SIZE = 8
BUFF_FONT_ID = "fb"  -- internal font identifier

                
function DoGauge (sPrompt, win, current, max, Colour)
  local width = WindowTextWidth (win, FONT_ID, sPrompt)  -- to right-justify it
  WindowText (win, FONT_ID, sPrompt, gauge_left - width + 5, vertical, 0, 0, ColourNameToRGB "#444444")
  
  gauge (win, sPrompt, 
          current, max, 
          gauge_left + 10, vertical, WINDOW_WIDTH - gauge_left - 20, font_height,
          ColourNameToRGB (Colour or "darkgreen"), ColourNameToRGB "gray",
          5, ColourNameToRGB "silver", -- ticks
          ColourNameToRGB "lightgrey",  -- frame
          0x444444)   -- shadow

  vertical = vertical + font_height + GAP_BETWEEN_BARS
end --  DoGauge
                

function OnPluginInstall ()
  
  player_win = GetPluginID () .. "_player"
  victim_win = GetPluginID () .. "_victim"

  -- make initial window
  WindowCreate (player_win, 0, 0, 0, 0, 0, 0, 0)
  -- add the fonts
  WindowFont (player_win, FONT_ID, FONT_NAME, FONT_SIZE)
  WindowFont (player_win, BUFF_FONT_ID, BUFF_FONT_NAME, BUFF_FONT_SIZE)
  -- find where window was last time
  player_windowinfo = movewindow.install (player_win, 4)
  
  -- see how high it is
  font_height = WindowFontInfo (player_win, FONT_ID, 1)  -- height
  buff_font_height = WindowFontInfo (player_win, BUFF_FONT_ID, 1)  -- height

  -- make initial window
  WindowCreate (victim_win, 0, 0, 0, 0, 0, 0, 0)
  -- add the fonts
  WindowFont (victim_win, FONT_ID, FONT_NAME, FONT_SIZE)
  WindowFont (victim_win, BUFF_FONT_ID, BUFF_FONT_NAME, BUFF_FONT_SIZE)
  -- find where window was last time
  victim_windowinfo = movewindow.install (victim_win, 5)
  
  -- get old colours, sequence etc.
  assert (loadstring (GetVariable ("player_info") or "")) ()
 
  player_info = player_info or { stats = {} }
  
  -- reset current figure, may have changed
  for k, v in pairs (player_info.stats) do
    v.cur = nil
    v.pct = nil
    victim_info.stats [k] = { clr = v.clr, seq = v.seq }
  end -- for each stat
  
end -- OnPluginInstall

function OnPluginEnable ()
  WindowShow (player_win, true)
end -- OnPluginDisable

function OnPluginDisable ()
  WindowShow (player_win, false)
  WindowShow (victim_win, false)
end -- OnPluginDisable

-- hide window on removal
function OnPluginClose ()
  WindowShow (player_win,  false)  -- hide it
  WindowShow (victim_win, false)
end -- OnPluginClose

function OnPluginSaveState ()
  movewindow.save_state (player_win)
  SetVariable ("player_info", 
               "player_info = " .. serialize.save_simple (player_info))
end -- OnPluginSaveState

player_info = { stats = {} }
victim_info = { stats = {} }

function Buff_Processing (tbl, win)
  local display_buffs

  if tbl then
    window_height = window_height + buff_font_height
    
    -- we may get: bless, bless  so we convert that to bless(2)
    local counted_buffs = {}
    for _, name in ipairs (tbl) do
      name = capitalize (name)
      counted_buffs [name] = (counted_buffs [name] or 0) + 1
    end -- for
    
    -- count them
    local total_buffs = 0
    for x in pairs (counted_buffs) do
      total_buffs = total_buffs + 1
    end -- for
    
    local count = 0
    display_buffs = {}
    
    -- add to new table with count and comma
    for name, n in pairsByKeys (counted_buffs) do
      count = count + 1
      if n > 1 then
        name = name .. "(" .. n .. ")"
      end -- if
      if count < total_buffs then
        name = name .. ", "
      end -- if
      table.insert (display_buffs, name)       
    end -- for
    
    local x = 5  
    
    -- see how many lines we need
    for _, name in ipairs (display_buffs) do
      local width = WindowTextWidth (win, BUFF_FONT_ID, name)
      if x + width >= WINDOW_WIDTH - 5 then
        x = 5
        window_height = window_height + buff_font_height
      end -- if new line
      x = x + width
    end -- for
        
  end -- if some buffs there
  
  return display_buffs
  
end -- function Buff_Processing

function Show_Buffs (tbl, colour, win)
 if tbl then
    -- seperator line
    WindowLine (win, 5, vertical, WINDOW_WIDTH - 5, vertical, ColourNameToRGB "darkgray", 0, 1)
    WindowLine (win, 6, vertical + 1, WINDOW_WIDTH - 4, vertical + 1, ColourNameToRGB "#444444", 0, 1)
    
    vertical = vertical + 2    
    local x = 5  
    
    for _, name in ipairs (tbl) do
      local width = WindowTextWidth (win, BUFF_FONT_ID, name)
      if x + width >= WINDOW_WIDTH - 5 then
        x = 5
        vertical = vertical + buff_font_height
      end -- if new line
      x = x + WindowText (win, BUFF_FONT_ID, name, x, vertical, 0, 0, colour)
    end -- for

  vertical = vertical + buff_font_height + GAP_BETWEEN_BARS
        
  end -- if some buffs there

end -- Show_Buffs

function Show_Stats_Bar (t, info, win, windowinfo)

  -- remember his level 
  info.level = t.level or info.level
  -- and name
  info.unitname = t.name or info.unitname

  -- can't pull things out of bar table if it isn't there
  if not t.bar then
    return
  end

  stats = info.stats
  
 -- find how many (eg. HP, mana, move)
  for k, v in pairs (t.bar) do
    stats [k] = stats [k] or {}
    -- save new stats in case not supplied in future
    stats [k].cur = v.cur or stats [k].cur
    stats [k].max = v.max or stats [k].max
    stats [k].pct = v.pct or stats [k].pct
    
    -- remember colour to display in
    stats [k].clr = v.clr or stats [k].clr
    
    -- display sequence (defaults to name)
    stats [k].seq = v.seq or stats [k].seq or k
  end -- for

  local labels = {}
  local gauge_count = 0
  for k, v in pairs (stats) do
    if (v.cur and v.max) or v.pct then
      table.insert (labels, k)
      gauge_count = gauge_count + 1
    end -- if something known
  end -- for
    
  if #labels == 0 then
    return
  end -- nothing known yet
  
  -- sort into wanted order
  table.sort (labels, function (a, b) return stats [a].seq < stats [b].seq end)
  
  window_height = (font_height * gauge_count) + (gauge_count * 2 + 1) * GAP_BETWEEN_BARS 
  if info.unitname or info.level then
    window_height = window_height + font_height + GAP_BETWEEN_BARS
  end -- if another line needed
    
  -- calculate lines needed for buffs
  local display_buffs   = Buff_Processing (t.buffs, win)

  -- calculate lines needed for debuffs
  local display_debuffs = Buff_Processing (t.debuffs, win)
  
  window_height = window_height + GAP_BETWEEN_BARS
  
  WindowCreate (win, 
                 windowinfo.window_left, 
                 windowinfo.window_top, 
                 WINDOW_WIDTH, window_height,  
                 windowinfo.window_mode,   -- top right
                 windowinfo.window_flags,
                 0) 

 
  -- let them move it around                 
  movewindow.add_drag_handler (win, 0, 0, 0, 0)

  -- work out how far in to start the gauge
  gauge_left =  max_text_width (win, FONT_ID, labels) + 5
  
  local background_colour = ColourNameToRGB "bisque"
  
  if t.dead then
    background_colour = ColourNameToRGB "mistyrose"
  elseif t.combat then 
    background_colour = ColourNameToRGB "rosybrown"
  end -- if
  
  -- fill entire box to clear it
  WindowRectOp (win, 2, 0, 0, 0, 0, background_colour)  -- fill entire box

  --[[
  -- some texture
  WindowCreate ("texture", 
                 0, 
                 0, 
                 WINDOW_WIDTH, window_height,  
                 4,   -- top right
                 0,  -- flags
                 ColourNameToRGB "limegreen")  -- colour
                                  
  WindowImageFromWindow (win, "tex", "texture")
        
  WindowBlendImage (win, "tex", 0, 0, 0, 0, 4, 0.02)
  
  --]]
  
  -- Edge around box rectangle
  --WindowCircleOp (win, 3, 0, 0, 0, 0, ColourNameToRGB "darkgray", 0, 2, 0, 1)
  --WindowRectOp (win, 5, 0, 0, 0, 0, 5, 15 + 0x1000)

  WindowCircleOp (win, 3, 0, 0, 0, 0, 0x505050, 0, 3, 0, 1)   -- dark grey border (3 pixels)
  WindowCircleOp (win, 3, 1, 1, -1, -1, 0x7C7C7C, 0, 1, 0, 1)  -- lighter inner border
  WindowCircleOp (win, 3, 2, 2, -2, -2, 0, 0, 1, 0, 1)  -- black inside that
  WindowLine (win, 1, 1, WINDOW_WIDTH - 1, 1, 0xC2C2C2, 0, 1)  -- light top edge
  WindowLine (win, 1, 1, 1, window_height - 1, 0xC2C2C2, 0, 1)  -- light left edge (for 3D look)
  
  vertical = 6  -- pixel to start at
  if info.unitname or info.level then
  
    -- seperator line
    WindowLine (win, 5, font_height + GAP_BETWEEN_BARS, WINDOW_WIDTH - 5, font_height + GAP_BETWEEN_BARS, 
                ColourNameToRGB "darkgray", 0, 1)
    WindowLine (win, 6, font_height + GAP_BETWEEN_BARS + 1, WINDOW_WIDTH - 4, font_height + GAP_BETWEEN_BARS + 1, ColourNameToRGB "#444444", 0, 1)

    -- show info.level number inside circle
    if info.level then
      local levelsize = WindowTextWidth (win, FONT_ID, info.level)
      local size = math.max (levelsize, font_height) + 4
      WindowCircleOp(win, 1, WINDOW_WIDTH - size , 0, WINDOW_WIDTH, size, 
                    ColourNameToRGB "#333333", 0, 3,  -- pen
                    ColourNameToRGB "lightgrey", 0) -- brush
      WindowCircleOp(win, 1, WINDOW_WIDTH - size + 1 , 1, WINDOW_WIDTH - 1, size - 1, 
                    ColourNameToRGB "#888888", 0, 1,  -- pen
                    0, 1) --  no brush
      WindowText (win, FONT_ID, info.level, WINDOW_WIDTH - size / 2 - levelsize / 2, 2, 0, 0, ColourNameToRGB "#444444")
    end -- of having info.level
    
    -- show player name
    if info.unitname then    
      WindowText (win, FONT_ID, capitalize (info.unitname), 5, 2, 0, 0, ColourNameToRGB "#444444")
    end -- of having info.unitname
    
    vertical = vertical + font_height + GAP_BETWEEN_BARS
  end

  -- make sure window visible
  WindowShow (win, true)
        
  -- show stats in sequence
  for _, name in ipairs (labels) do
    local st = stats [name]
    
    if st.pct then
      DoGauge (name, win, st.pct, nil,    st.clr)
    else
      DoGauge (name, win, st.cur, st.max, st.clr)
    end -- if
  end -- for
  
  vertical = vertical + 1
  
  -- buffs
  Show_Buffs (display_buffs, ColourNameToRGB "#003C00", win)
  
  -- debuffs
  Show_Buffs (display_debuffs, ColourNameToRGB "darkred", win)

end -- Show_Stats_Bar

function OnPluginTelnetOption (option)

  local t = {}  -- incoming server variables will go into table t
  setfenv (assert (loadstring (option)), t) () -- compile and load into t
  
  Show_Stats_Bar (t, player_info, player_win, player_windowinfo)

  if t.victim then
    Show_Stats_Bar (t.victim, victim_info, victim_win, victim_windowinfo)
  else
    WindowShow (victim_win, false)
  end -- if
  
end -- function OnPluginTelnetOption

function OnPluginTelnetRequest (type, data)
  if type == 102 and data == "WILL" then
    return true
  end -- if
end -- function OnPluginTelnetRequest

-- on a new connection, this might be a new character, and name
-- and all stats different
function OnPluginConnect ()
  WindowShow (player_win, false)
  player_info = { stats = {} }
  victim_info = { stats = {} }
end -- OnConnect

]]>
</script>

</muclient>
