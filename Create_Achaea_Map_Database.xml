<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, March 04, 2010, 9:11 AM -->
<!-- MuClient version 4.50 -->

<!-- Plugin "Create_Achaea_Map_Database" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Create_Achaea_Map_Database"
   author="Nick Gammon"
   id="d91aff8af0ad44c3910394ce"
   language="Lua"
   purpose="Creates the Achaea Map database from their XML file"
   save_state="y"
   date_written="2010-03-04 09:10:51"
   requires="4.50"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Type "create map database" to run.
]]>
</description>

</plugin>


<aliases>
  <alias
   script="create_map_database"
   match="create map database"
   enabled="y"
   sequence="100"
  >
  </alias>
</aliases>


<!--  Script  -->


<script>
<![CDATA[

count = 0
roomcount = 0
endroomcount = 0
areacount = 0
coordcount = 0
directioncount = 0

entities = { ['&amp;']  = '&';
             ['&quot;'] = '"';
             ['&lt;']   = '<';
             ['&gt;']   = '>';
           }
       
directions = {}
    
convert_direction = {
  north = "n",
  south = "s",
  east = "e",
  west = "w",
  up = "u",
  down = "d",
  northeast = "ne",
  northwest = "nw",
  southeast = "se",
  southwest = "sw",
  ['in'] = "in",
  out = "out",
  }
  
function  process_area (areaid, areaname)
  areacount = areacount + 1
  
  dbcheck (db:execute (string.format (
    "INSERT INTO areas (uid, name, date_added) VALUES (%s, %s, DATETIME('NOW'));",
      fixsql (areaid), 
      fixsql (string.gsub (areaname, '&%a-;', entities))
    )))
               
end --  process_area 

function process_start_room (roomid, areaid, roomtitle)
  roomcount = roomcount + 1
  room = { id = roomid, area = areaid, title = string.gsub (roomtitle, '&%a-;', entities) }
  exits = {}
  coords = {}
end -- process_start_room

function process_end_room ()
  endroomcount = endroomcount + 1
  if next (coords) == nil then
    print ("no coords for room", room.id)
  else
    dbcheck (db:execute (string.format (
      "INSERT INTO rooms (uid, name, area, building, x, y, z, date_added) VALUES (%s, %s, %s, %s, %i, %i, %i, DATETIME('NOW'));",
        fixsql (room.id), 
        fixsql (room.title),
        fixsql (room.area),
        fixsql (coords.building),
        coords.x,
        coords.y,
        coords.z
      )))
    
    for dir, exit in pairs (exits) do
       dbcheck (db:execute (string.format ([[
          INSERT INTO exits (dir, fromuid, touid, date_added) 
              VALUES (%s, %s, %s, DATETIME('NOW'));
        ]], fixsql  (dir),  -- direction (eg. "n")
            fixsql  (room.id),         -- from current room
            fixsql  (exit)    -- destination room
            )))
    end -- for each exit

    dbcheck (db:execute (string.format ([[
      INSERT INTO rooms_lookup (uid, name) VALUES (%s, %s);
    ]], fixsql  (room.id),       
        fixsql  (room.title) 
        )))
            
  end -- if
end -- process_end_room

function process_coord (x, y, z, building)
  coordcount = coordcount + 1
  coords = { x = x, y = y, z = z, building = building}
end -- process_coord

function process_direction (direction, target)
  directioncount = directioncount + 1
  directions [direction] = (directions [direction] or 0) + 1
  exits [convert_direction [direction]] = target
end -- process_direction

function dbcheck (code)

 if code ~= sqlite3.OK and    -- no error
    code ~= sqlite3.ROW and   -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
    local err = db:errmsg ()  -- the rollback will change the error message
    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
    error (err, 2)            -- show error in caller's context
  end -- if

end -- dbcheck 

function fixsql (s)
  if s then
    return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
  else
    return "NULL"
  end -- if
end -- fixsql

function fixbool (b)
  if b then
    return 1
  else
    return 0
  end -- if
end -- fixbool


function create_map_database (name, line, wildcards)


  -- open database on disk 
  db = assert (sqlite3.open(GetInfo (66) .. "achaea_map.db"))
  
  -- create rooms table
  dbcheck (db:execute[[
  
  PRAGMA foreign_keys = ON;
  
  DROP TABLE IF EXISTS areas;
  
  CREATE TABLE areas (
      areaid      INTEGER PRIMARY KEY AUTOINCREMENT,
      uid         TEXT    NOT NULL,   -- vnum or how the MUD identifies the area
      name        TEXT,               -- name of area
      date_added  DATE,               -- date added to database
      UNIQUE (uid)
    );

  DROP TABLE IF EXISTS rooms;

  CREATE TABLE rooms (
      roomid        INTEGER PRIMARY KEY AUTOINCREMENT,
      uid           TEXT NOT NULL,   -- vnum or how the MUD identifies the room
      name          TEXT,            -- name of room
      area          TEXT,            -- which area
      building      TEXT,            -- which building it is in
      x             INTEGER,
      y             INTEGER,
      z             INTEGER,
      date_added    DATE,            -- date added to database
      UNIQUE (uid)
--      FOREIGN KEY(area) REFERENCES areas(uid)
    );

  DROP TABLE IF EXISTS exits;
           
  CREATE TABLE exits (
      exitid      INTEGER PRIMARY KEY AUTOINCREMENT,
      dir         TEXT    NOT NULL, -- direction, eg. "n", "s"
      fromuid     STRING  NOT NULL, -- exit from which room (in rooms table)
      touid       STRING  NOT NULL, -- exit to which room (in rooms table)
      date_added  DATE,             -- date added to database
      FOREIGN KEY(fromuid) REFERENCES rooms(uid)
    );
  CREATE INDEX IF NOT EXISTS fromuid_index ON exits (fromuid);
  CREATE INDEX IF NOT EXISTS touid_index   ON exits (touid);
  
  DROP TABLE IF EXISTS rooms_lookup;
      
  CREATE VIRTUAL TABLE rooms_lookup USING FTS3(uid, name);
  ]])
  
  
  db:exec ("BEGIN TRANSACTION;") 
    
  for line in io.lines ("map.xml") do
    
    local xml = string.match (line, "^%s*<(.-)/?>%s*$")
    
    if xml then
      local areaid, areaname  = string.match (xml, '^area%s+id="(%d+)"%s+name="(.+)"%s*$')
    
      if areaid then
        process_area (tonumber (areaid), areaname)
      else
        local roomid, areaid, roomtitle  = string.match (xml, '^room%s+id="(%d+)"%s+area="(%d+)"%stitle="(.+)"%s*$')
        if roomid then
          process_start_room (tonumber (roomid), tonumber (areaid), roomtitle)
        elseif string.match (xml, "^/room$") then
          process_end_room ()
        else
         local x, y, z = string.match (xml, '^coord%s+x="(-?%d+)"%s+y="(-?%d+)"%sz="(-?%d+)"%s*$')
         if x then
            process_coord (tonumber (x), tonumber (y), tonumber (z))
         else
           local x, y, z, building = string.match (xml, '^coord%s+x="(-?%d+)"%s+y="(-?%d+)"%sz="(-?%d+)"%sbuilding="(-?%d+)"%s*$')
           if x then
              process_coord (tonumber (x), tonumber (y), tonumber (z), tonumber (building))
           else
             local direction, target = string.match (xml, '^exit%s+direction="(%a+)"%s+target="(%d+)"%s*$')
             if direction then
              process_direction (direction, tonumber (target))
             else
               print ("unprocessed line:", xml)
             end -- if not a direction
           end   -- not a coord/building line     
         end     -- if not a coord line
        end -- if  not a room line
      end -- if  not an area line
      
      count = count + 1
      else
        print ("Line not processed:", line)
    end -- xml
    
  end --  for each line
  
  db:exec ("COMMIT;") 
  
  print ("found", count, "xml lines")
  print ("found", areacount, "areas")
  print ("found", roomcount, "rooms")
  print ("found", endroomcount, "/rooms")
  print ("found", coordcount, "coordinates")
  print ("found", directioncount, "directions")
  
  --for k, v in pairs (directions) do
  --  print (k, v)
  --end -- for

end -- function create_map_database

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="Create_Achaea_Map_Database:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
